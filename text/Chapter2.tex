\section{Обзор существующих решений}
\label{sec:Chapter2} \index{Chapter2}
\todo[inline]{Здесь надо рассмотреть все существующие решения поставленной задачи, но не просто пересказать, в чем там дело, а оценить степень их соответствия тем ограничениям, которые были сформулированы в постановке задачи.}

Существующие стратегии динамического тестирования можно разделить на четыре класса:
- Random-based - основаны на случайных нажатиях на экран (очень быстро, невоспроизводимые тесты, тесты отличные от реального взаимодействия с устройством);
- Search-based (На практике хуже чем, model-based) - основаны на приближенном решении задач оптимизации (генетические алгоритм);
- Model-based - основаны на построении модели приложения либо до тестирования, либо во время тестирования (state-of-the-art подходы, все сравнисаются с ними);
- Hybrid - совмещвет в себе две стратегии (random + model-based).

Есть несколько работ по внедрению Q-learning алгоритмов для динамического тестирования, но они обладают некоторыми недостатками:
- Нет открытого исходного кода с реализацией;
- Используют медленный UI-automator (в отличии от быстрого DroidBot);
- Сомнительный дизайн элементов RL (представление состояние).
Также некоторые, близкие к нашей задаче, работы используют Q-learning подход для десктоп приложений. Поэтому основной задачей ставится внедрение RL в систему DroidBot

Automated Test Input Generation for Android (2015) - Почему Андроид? Основные критерии качества автоматического тестирования. Сравнение подходов по этим керитериям на 2015 год.

QBE (2018) - Первая реализация Q-learning. Пседвокод алгоритмов Q-learning. Матрица Q формируется до тестирования на тренировочном наборе. Основана на абстрактных состояниях (кластеризация состояний по количеству UI элементов). Пути улучшения Q-learning.

RLBasedApproach (2018) - Хорошее описание алгоритма Q-learning с формулами. Онлайн обучение во время тестирования. Вознаграждение за состояние с большим количеством уникальных элементов + редкость действия в этом сотоянии.

DRIFT (2020) - Хорошее, понятное введение. Используется RNN для преобразования дерева в state. Решается немного другая задача: достичь конкретного действия во время тестирования. Поэтому награда дается за достижения этого действия. Тестирование Windows приложений. Есть небольшое упонимание о компромисе между быстрым достижением цели и покрытием состояний приложения.

Reinforcement Learning for Android GUI Testing (2018) - Очень простая идея. Награда - обратная чатота данного взяимодейсвия в данном состоянии. В процессе тестирования формируется Q-таблица. Хорошо описан алгоритм и приведен пример его работы. Сравнение с рандомной стратерией. Статистическией критерий для обоснования превосходства. В заключении возможные пути улучшения.


DroidbotX: Test Case Generation Tool for Android Applications Using Q-Learning

Исследователи уже более десяти лет ведут работы в направлении автоматизации тестирования мобильных приложений. В этой части будут описаны существующие решения похожих задач и выделены их преимужества и недостатки.

Для начала стоит отметить, что все существующие подходы можно разбить на три группы:

- основанные на случаных нажатиях

- основанные на модели взаимодейсвий

- основанные на систематическом тестировании

%%%%%%%%%%%%%%%%% Можно зааиспользовать в рандомном  подходе
Самым простым и самым популярным подходом к автоматическому тестированию является подход на основе случайных нажаний на экран[13, 19, 21, 27]. Но этот подход имеет ряд ограничений. Во-первых, в такой постановке невозможно определить те состояния, которые уже были протестированы. Тем самым тестирование может проходить по одним и тем же состояниям, не уделяя должного внимания еще не исследованным состояниям. Во-воторых, с помощью таких тестов невозможно выполнить заданную последовательность действий для достиения неисследованного стостояния(???).

[4,7] из QBE
Недостаток случайной стратегии в том, что
тесты трудно воспроизвести, а неисправности трудно локализовать. Что еще более важно, такой подход может генерировать тысячи нажатий на графический интерфейс в секунду, что нереально с точки зрения человеческого использования. Так же, в случаной стратерии могут генерироваться внезапные паденияили или повышения уровня заряда батареи и внезапные изменения ориентации телефона, что нехарактарно для стандартных сценариев использования стартфона.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Подходы, основанные на случайных нахатиях - одини из самых популярных методов обнаружения сбоев в приложении. Идея такого тестирования проста: с большой частотой генерируются нажатия на экран в случаной позиции. Этот метод может быть пригодным для эффективного стресс-тестирования (тестирование за пределами нормального использования приложения). Например, Android Monkey [27] - это инструмент случайного тестирования в виде черного ящика в Android SDK (Software Development Kit). Среди современных инструментов генерации тестов этот инструмент приобрел значительную популярность в сообществе. Помимо простоты, он продемонстрировал хорошую совместимость с множеством Android платформ, что сделало его стандартом в промышленных применениях[19,46]. Однако Android Monkey требуется много времени для генерации длинной последовательности событий. В последовательности событий часто встресаются повторяющиеся действия, которые многократно сменяют друг друга и не приводят к исследованию новых состояний. Также недостатоком этого подхода являются многочисленные нажатия на неитерактивные элементы, что не может приводить к новым состояниям [44,47,48]. В связи с этим был разработан новый подход пороверх Android Monkey для автоматического обнаружения сбоев пользовательского интерфейса - Dynodroid [13]. В нем используется дополнительные эвристики, благодаря которым случайный выбор действия зависит от состояния в котором находится тестируемое приложение. Таким образом метод повторяет один и тот же цикл действий: получание сотояния, выбор действия, выполение действия. Тем не менее, Dynodroid использует дополнительные инструменты, чтобы эффективно направлять исследования. Еще один случайный подход SmartMonkey [50] использует дополнительные алгоритмы[45], чтобы уменьшить количество тестовых примеров и время, необходимое для выявления первой неисправности. Он создает модель переходов приложения на основе случайного взаимодействия и генерирует тестовые примеры с помощью метода случайного блуждания. SmartMonkey помимо пользовательских, может генерировать системные события.

Тестирование на основе моделей предполагает использование модели на основе графов для представления взаимодействия пользователя с графическим интерфейсом приложения. Модель разрабатывается вручную или автоматически путем исследования кода или файлов конфигурации, или путем прямого взаимодействия с приложениями. Тестирование на основе модели может быть направлено на исследование плохо изученных состояний с спользованием определенных стратегий: обход в глубину, обход в ширину, гибридная[23] или стохастическая [15]. Однако, этот подход чувствителен к точности построенной модели. В частности, слишком чувствительная к изменениям модель, построенная с учетом малейших изменений графического интерфейса не сможет эффективно исследовать новые состояния. Обратно, модель интерфейса пользователя, которая включает ограниченное число взаимодействий минимизирует эффективность тестирования. Как показано в одной из работ[51] многоуровневое представление состояний влияюем на эффективность инструмента мод. A3E [23] исследует приложения с использованием двуух стратегий: исследование в глубину, которое систематически анализирует приложения без доступа к исходному коду, и целевое исследование, при котором приоритетное внимание уделяется изучению действий, которые начинаются с первого действия на графе переходов статической активности. A3E представляет каждое автивити как отдельное состояние без учета того, что активити может существовать в разных состояниях. Это приводит к отсутствию некоторых вариантов поведения приложения, поскольку не все состояния в активити исследуются. Orbit [52] статически анализирует исходный код приложений, чтобы генерировать соответствующие события, поддерживаемые приложением. Однако он использует простое исследование в глубину, которое перезапускает приложение чтобы к предыдущим состояниям. PUMA [53] включает универсальный UI Automator, который реализует тот же базовый случайный подход, что и Android Monkey; однако он отличается по своей конструкции и использует динамический анализ который реарирует на изменения в среде во время выполнения приложения. Ape [54] использует подход динамического моделирования для оптимизации исходной модели графического интерфейса а счет использования информации, полученой во время выполнения.

Систематическое тестирование использует более сложные методы, такие как символьное исполнение и эволюционные алгоритмы для генерации определенных тестовых данных. Преимущество этого подхода заключается в том, что он может использовать исходный код для создания тестов. CrashScope [56] автоматически обнаруживает сбои AUT, используя гибридную стратегию, сочетающую систематическое исследование и статический анализ. SIG-Droid [58] - это автоматизированный системный инструмент генерации ввода для приложений Android, который сочетает методы анализа программ и символьное исполнение для достижения высокого покрытия кода. Sapienz [16] использует автоматический многоцелевой подход к тестированию на основе поиска. Он адаптирует генетические алгоритмы для оптимизации тестовой последовательности для максимального покрытия кода и обнаружения ошибок при минимальной длине тестовой последовательности. Sapienz исследует приложение, используя определенные графические интерфейсы и сложные последовательности действий с заранее заданным шаблоном. Предопределенный шаблон позволяет отражать опыт специалистов по тестированию в автоматических методах. За счет объединения двух стратегий этот метод показывает хорошую эффективность тестирования.

% Добавить про q-learning из моих статей