\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\label{sec:Chapter0} \index{Chapter0}

Операционная система Android является одной из доминирующих на современном рынке смартфонов. Исследования показывают [1], что на мобильном устройстве в среднем установлено от 60 до 90 приложений и пользователь тратит на приложения более двух частов в день. Следовательно, проверка надежности и функциональности приложения - важная задача. Как показывает статистика [2], большинство пользователей отказываются от использования приложения в случае его сбоя. Неправильное функционирование графического интерфейса не позволяет пользователям комфортно эксплуатировать весь потециал приложений, который предоставляют разработчики. Ошибка приложения не только создает неудобства для пользователей, но и отрицательно сказывается на рейтинге продукта. Низкое качество Android-приложений можно объяснить недостаточным вниманием к тестированию в связи с быстротой развития сферы [3]. Разработчики пренебрегают тестированием, поскольку этот процесс считается трудоемким, дорогостоящим и сопряженным с многократным повторением однотипных действий.

Избежать сбоев в работе мобильных приложений можно еще на этапе разработки, если основательно подходить к тесированию продукта. Тестировать приложенияния во время их разработки это один из ключевых элементов современного проектироания программного обеспечения. Причем необходимо делать это на всех этапах разработки с помощью непрерывной интергации и непрерывной доставки, иначе можно упустить мелкие баги и недочеты, которые в результате превратятся в плохой пользовательский оптыт использования. Одним из основных видов тестирования конечного продукта является тестирования графического интерфейса пользователя. С его помощью проверяется функциональность мобильных приложений при взаимодейтии с пользователем до того, как это приложение будет выпущено на рынок. Суть тестирования в том, чтобы посещать различные состояния приложения и взаимодействовать с разными интерактивными элементами путем нажатий на экран смартфона, без использования исходного кода приложения.

Автоматическое тестирование приложений начинается с создания тестовых примеров которые представляют из себя последовательности действий пользователя при взаимодействии с приложением. Разработка тестовых примеров обычно занимает много времени, так как производится вручную. Из-за масштаба приложений на рынке и большого количества способов взаимодействия с ними такое тестирование становится дорогим и неэффективным. На практике можно столкнуться с тем, что тестирование занимает несколько часов, а небольше изменения в приложении могут привести к образованию новых багов, что требует повторного тестирования [11]. Поэтому компании часто выпускают бета-версии своих продуктов, чтобы тестированием занимались пользователи. 
За поледние 10 лет было придумано и разработано много альтернативных инструментов, предназначеных для автоматического создания тестовых примеров. Эти интрументы можно условно разделить на четыре группы в зависимости от подхода:

 - основаные на случайных нажатиях [4, 5, 6]
 
 - основанные на моделях []
 
 - систематическое обучение []
 
 - обучение с подкреплением []
 
Любое автоматическое тестирование состоит из множества повторений одних и тех же последовательностей действий: получение состояния, генерация нажатия, воспроизведение нажатия. Самым требовательным этапом является генерация нажатия, поскольку от него зависит общая эффективность процесса тестирования. Все существующие подходы занимаются иследованием именно этого этапа. Однако существуют проблемы с низким уровнем покрытия кода существующих инструментов [7]. Причиной этого является невозможность изучить сложные состояний приложения, достижымые только через конкретные последовательности действий. Такие инструменты должны не только выбирать с каким компонентом графического интерфейса взаимодействовать, но и тип взаимодейстия. Из всех жестов доступных для пользователя можно выделить нажатие, двойное нажатие, свайп и удержание. Программа автоматического тестирования должна их поддерживать. Большое число типов взаимодействия должно увеличивать эффективность тестирования. 

Для измерения эффективности того или иного подхода используются различные метрики. Из самых важных показателей эффективности [8] можно выделить следующие:

- количество уникальных состояний открытых во время тестирования

- количество открытых Активностей приложения (соответствует принятому в англо-язычном сообществе термину Activity)

- покрытие кода приложения

- количество найденных сбоев и ошибок

Основными показателями эффективности в этой работе будут являться первые две метрики, потому что их числовые значения информативны и интуитивно понятны. Проблема представления состояния приложения с данной работе решается следующим образом: будем считать, что состояния являются одинаковыми, если список возможных взаимодействий с этих стостояниях совпадает. Что касается Активности приложения, то ее тоже можно сопоставлять с некоторым понятием состояния. Отличие состоит в том, что Активность приложения является более обобщенным понятием состояния, котрое является единым для всех приложений и пользователей. Несколько сотояний в нашем понимании может находиться в одной Активности. Измерение только Активности приложения может быть недостаточо, так как приложение может содержать только одну Активность и при этом множество состояний. Таким образом метрика Активности приложения всегда будет ниже метрики состояний, но при этом эти метрики независимы и хорошо отражают степень покрытия приложения при тестировании. Если говорить про две последнии метрики, то они будут сильно зависить от первых двух. Каждая активность содержит определенное количество строк исходного кода приложения. Если мы открываем новую Активность - мы покрываем код, находящийся в этой активности. Чем больше Активностей или сотояний мы откроем, тем больше кода окажется протестированными. С ошибками и сбоями ситуация аналогичная - больший охват приложения способен обнаружить больше потенциальных сбоев.

В данной работе исследуются подходы, которые генерирует тестовые примеры на основе техники Q-Learning. Техника Q-Learning использует метод проб и ошибок для достижения состояний, которые еще не были исследованы. Общая идея в том, что каждое взаимодействие в каждом состоянии оценивается некоторой функцией награды. Функция награды формируется таким образом, чтобы давать большее вознаграждение за полезные действия и штрафовать за бесполезные. В процессе исследования приложения мы пытаемся научить алгоритм предсказывать какое действие приведет к большей суммарной награде и тем самым позволит исследовать как можно больше состояний.  Реализиция алгоритмов и проверка эвристик этих алгоритмов проводилась в инструенте DroidBot [9]. Droidbot создает модель перехода между состояниями приложения и воспроизводит тестовые примеры.

В этой работе были проведены экспериметы на 6-и приложениях различных категорий с использованием различных модификаций Q-learning подходов. Результаты показываеют, что добавление логичных эвристик даже в самые простые реализации способно значимо повысить производительномть тестирования. Также было выяснено, что не все современные подходы способны удовлетворять требованиям практического применения алгоритмов. В конце было произведено сравнение наших реализаций Q-learning алгоритма с известным инструментом тестирования на основе глубоких нейронных сетей Humanoid [10].  